command:
  base64
level:
  0
script: |
  require "optparse"
  require "base64"
  require "kconv"

  def base64(*arguments)
    mode = nil
    args = {}
    opt = OptionParser.new

    opt.on("-e VALUE", "--encode VALUE", "String encode. convert to base64 strings from context strings"){|v|
      mode = :encode
      args[:from] = v}
    opt.on("-d VALUE", "--decode VALUE", "String decode. decode to context strings from base64 strings"){|v|
      mode = :decode
      args[:from] = v}
    opt.on("--fe=from,to", "File encode. convert to base64 from arguments file data"){|e|
      mode = :fencode
      args[:from] = e[0]
      args[:to]   = e[1]}
    opt.on("--fd=from,to", "File decode. decode to original data from arguments file"){|e|
      mode = :fdecode
      args[:from] = e[0]
      args[:to]   = e[1]}

    if arguments.empty?
      arguments << "-h"
    end
    opt.parse!(arguments)

    if mode == :encode
      b64s = Base64.encode64(Kconv.kconv(args[:from], Kconv::UTF8))
      result({
        "Mode" => "String Encode",
        "Base String" => args[:from],
        "Result" => b64s
      })
    elsif mode == :decode
      context = Base64.decode64(args[:from])
      result({
        "Mode" => "Decode String",
        "Base String" => args[:from],
        "Result" => context
      })
    elsif mode == :fencode
      if filecheck(args[:from])
        File.write(args[:to], Base64.encode64(File.binread(args[:from])))
      end
    elsif mode == :fdecode
      if filecheck(args[:from])
        File.write(args[:to], Base64.decode64(File.binread(args[:from])))
      end
    end
  end

  def result(hash)
    hash.each do |key, value|
      puts "#{key} : #{value}"
    end
  end

  def filecheck(fName)
    unless File.exists?(fName)
      puts "#{fName} No such file"
      return false
    end
    return true
  end

